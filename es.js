!function(){"use strict";const e=e=>"querySelectorAll"in e,{filter:t}=[];var r=r=>{const l=new WeakMap,o=l=>{const{query:o}=r;if(o.length)for(let r=0,{length:s}=l;r<s;r++)n(t.call(l[r].addedNodes,e),!0,o),n(t.call(l[r].removedNodes,e),!1,o)},n=(e,t,o,a=new Set)=>{for(let c,u,i=0,{length:h}=e;i<h;i++)if(!a.has(u=e[i])){if(a.add(u),t)for(let e,n=s(u),a=0,{length:i}=o;a<i;a++)n.call(u,e=o[a])&&(l.has(u)||l.set(u,new Set),c=l.get(u),c.has(e)||(c.add(e),r.handle(u,t,e)));else l.has(u)&&(c=l.get(u),l.delete(u),c.forEach(e=>{r.handle(u,t,e)}));n(u.querySelectorAll(o),t,o,a)}},s=e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector,a=(e,t=!0)=>{n(e,t,r.query)},c=new MutationObserver(o),u=r.root||document,{query:i}=r;return c.observe(u,{childList:!0,subtree:!0}),i.length&&a(u.querySelectorAll(i)),{drop:e=>{for(let t=0,{length:r}=e;t<r;t++)l.delete(e[t])},flush:()=>{o(c.takeRecords())},observer:c,parse:a}};const{attachShadow:l}=Element.prototype,{defineProperty:o,getOwnPropertyNames:n,setPrototypeOf:s}=Object,{define:a,get:c}=customElements,{createElement:u}=document,i=new WeakMap,h=new Map,d=new Map,p=new Map,f=new Map,m=new Set,y=[],g=[],b=e=>{for(let t=0,{length:r}=e;t<r;t++){const{target:r,attributeName:l,oldValue:o}=e[t],n=r.getAttribute(l);r.attributeChangedCallback(l,o,n)}},w=(e,t)=>{const{observedAttributes:r}=e.constructor;return r&&A(t).then(()=>{new MutationObserver(b).observe(e,{attributes:!0,attributeOldValue:!0,attributeFilter:r}),r.forEach(t=>{e.hasAttribute(t)&&e.attributeChangedCallback(t,null,e.getAttribute(t))})}),e},E=e=>f.get(e)||c.call(customElements,e),v=(e,t,r)=>{const l=p.get(r);if(t&&!l.isPrototypeOf(e)){M=s(e,l);try{new l.constructor}finally{M=null}}const o=(t?"":"dis")+"connectedCallback";o in l&&e[o]()},{parse:S}=r({query:g,handle:v}),{parse:q}=r({query:y,handle(e,t){i.has(e)&&(t?m.add(e):m.delete(e),k.call(g,e))}}),A=e=>{if(!d.has(e)){let t,r=new Promise(e=>{t=e});d.set(e,{$:r,_:t})}return d.get(e).$};let M=null;function k(e){const{parse:t,root:r}=i.get(e);t(r.querySelectorAll(this),e.isConnected)}n(self).filter(e=>/^HTML(?!Element)/.test(e)).forEach(e=>{function t(){const{constructor:e}=this;if(!h.has(e))throw new TypeError("Illegal constructor");const{is:t,tag:r}=h.get(e);if(M)return w(M,t);const l=u.call(document,r);return l.setAttribute("is",t),w(s(l,e.prototype),t)}s(t,self[e]),(t.prototype=self[e].prototype).constructor=t,o(self,e,{value:t})}),o(Element.prototype,"attachShadow",{value(){const e=l.apply(this,arguments),{parse:t}=r({query:g,root:e,handle:v});return i.set(this,{root:e,parse:t}),e}}),o(customElements,"define",{value(e,t,r){let l;const o=r&&r.extends;if(o){if(E(e))throw new Error(`the name "${e}" has already been used with this registry`);l=`${o}[is="${e}"]`,h.set(t,{is:e,tag:o}),p.set(l,t.prototype),f.set(e,t),g.push(l)}else a.apply(customElements,arguments),y.push(l=e);A(e).then(()=>{o?(S(document.querySelectorAll(l)),m.forEach(k,[l])):q(document.querySelectorAll(l))}),d.get(e)._()}}),o(customElements,"get",{value:E}),o(customElements,"whenDefined",{value:A}),o(document,"createElement",{value(e,t){const r=t&&t.is;return r?new(f.get(r)):u.call(document,e)}})}();
