!function(){"use strict";const e=e=>"querySelectorAll"in e,{filter:t}=[];var r=r=>{const l=new WeakMap,o=l=>{const{query:o}=r;if(o.length)for(let r=0,{length:s}=l;r<s;r++)n(t.call(l[r].addedNodes,e),!0,o),n(t.call(l[r].removedNodes,e),!1,o)},n=(e,t,o,a=new Set)=>{for(let c,u,i=0,{length:h}=e;i<h;i++)if(!a.has(u=e[i])){if(a.add(u),t)for(let e,n=s(u),a=0,{length:i}=o;a<i;a++)n.call(u,e=o[a])&&(l.has(u)||l.set(u,new Set),c=l.get(u),c.has(e)||(c.add(e),r.handle(u,t,e)));else l.has(u)&&(c=l.get(u),l.delete(u),c.forEach(e=>{r.handle(u,t,e)}));n(u.querySelectorAll(o),t,o,a)}},s=e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector,a=(e,t=!0)=>{n(e,t,r.query)},c=new MutationObserver(o),u=r.root||document,{query:i}=r;return c.observe(u,{childList:!0,subtree:!0}),i.length&&a(u.querySelectorAll(i)),{drop:e=>{for(let t=0,{length:r}=e;t<r;t++)l.delete(e[t])},flush:()=>{o(c.takeRecords())},observer:c,parse:a}};const{attachShadow:l}=Element.prototype,{defineProperty:o,setPrototypeOf:n}=Object,{define:s,get:a}=customElements,{createElement:c}=document,u=new WeakMap,i=new Map,h=new Map,d=new Map,f=new Map,p=new Set,m=[],y=[],g=e=>{for(let t=0,{length:r}=e;t<r;t++){const{target:r,attributeName:l,oldValue:o}=e[t],n=r.getAttribute(l);r.attributeChangedCallback(l,o,n)}},b=(e,t)=>{const{observedAttributes:r}=e.constructor;return r&&S(t).then(()=>{new MutationObserver(g).observe(e,{attributes:!0,attributeOldValue:!0,attributeFilter:r}),r.forEach(t=>{e.hasAttribute(t)&&e.attributeChangedCallback(t,null,e.getAttribute(t))})}),e},w=(e,t,r)=>{const l=d.get(r);if(t&&!l.isPrototypeOf(e)){q=n(e,l);try{new l.constructor}finally{q=null}}const o=(t?"":"dis")+"connectedCallback";o in l&&e[o]()},{parse:E}=r({query:y,handle:w}),{parse:v}=r({query:m,handle(e,t){u.has(e)&&(t?p.add(e):p.delete(e),A.call(y,e))}}),S=e=>{if(!h.has(e)){let t,r=new Promise(e=>{t=e});h.set(e,{$:r,_:t})}return h.get(e).$};let q=null;function A(e){const{parse:t,root:r}=u.get(e);t(r.querySelectorAll(this),e.isConnected)}Reflect.ownKeys(self).filter(e=>"string"==typeof e&&/^HTML(?!Element)/.test(e)).forEach(e=>{function t(){const{constructor:e}=this;if(!i.has(e))throw new TypeError("Illegal constructor");const{is:t,tag:r}=i.get(e);if(q)return b(q,t);const l=c.call(document,r);return l.setAttribute("is",t),b(n(l,e.prototype),t)}n(t,self[e]),(t.prototype=self[e].prototype).constructor=t,o(self,e,{value:t})}),o(Element.prototype,"attachShadow",{value(){const e=l.apply(this,arguments),{parse:t}=r({query:y,root:e,handle:w});return u.set(this,{root:e,parse:t}),e}}),o(customElements,"define",{value(e,t,r){let l;const o=r&&r.extends;if(o){if(f.has(e))throw new Error(`the name "${e}" has already been used with this registry`);l=`${o}[is="${e}"]`,i.set(t,{is:e,tag:o}),d.set(l,t.prototype),f.set(e,t),y.push(l)}else s.apply(customElements,arguments),m.push(l=e);S(e).then(()=>{o?(E(document.querySelectorAll(l)),p.forEach(A,[l])):v(document.querySelectorAll(l))}),h.get(e)._()}}),o(customElements,"get",{value:e=>f.get(e)||a.call(customElements,e)}),o(customElements,"whenDefined",{value:S}),o(document,"createElement",{value(e,t){const r=t&&t.is;return r?new(f.get(r)):c.call(document,e)}})}();
